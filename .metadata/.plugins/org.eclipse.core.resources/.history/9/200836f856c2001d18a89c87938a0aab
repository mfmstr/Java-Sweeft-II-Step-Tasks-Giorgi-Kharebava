package javasweeftsecondsteptasks.tasks;

public class Second {
	
	/* პრობლემა: 
	 გვაქვს 1,5,10,20 და 50 თეთრიანი მონეტები. დაწერეთ ფუნქცია, რომელსაც გადაეცემა თანხა (თეთრებში) 
	 და აბრუნებს მონეტების მინიმალურ რაოდენობას, რომლითაც შეგვიძლია ეს თანხა დავახურდაოთ.
	 Int minSplit(Int amount);
	*/
	
	/* გადაწყვეტა: 
	 იმისათვის, რომ შემოსული რაოდენობა(თეთრებში) მინიმალური რაოდენობის მონეტით გადავახურდავოთ,
	 მაშინ მაქსიმალურად უნდა ვეცადოთ რომ ყველაზე დიდი მნიშვნელობის მქონე მონეტა(მონეტები) იმდენჯერ გამოვიყენოთ,
	 რამდენჯერაც შესაძლებელია, ხოლო როდესაც დიდი რაოდენობის მონეტა(ამ შემთხვევაში 50) აღარ ჩაეტევა, ანუ მეტი
	 იქნება დარჩენილ გადასახურდავებელ თანხაზე, მაშინ მონეტის რაოდენობა ჩამოვიყვანოთ მასზე ყველაზე ახლო მნიშნველობის
	 მქონდე დაბალ მონეტამდე. 50 -> 20 -> 10 -> 5 -> 1;
	 
	 ტექნიკური მხარე:
	 
	 შევქმნათ მონეტების მასივი და დავალაგოთ კლებადობით, რადგან ლუპის დროს როგოც ზემოთ ავღნიშნე მაქსიმალურიდან
	 მინიმალურისკენ ჩამოვიდეს და კონკრეტული მონეტა გამოვიყენოთ მანამ, ვიდრე დასახურდავებელ თანხას არ აღებატება(while
	 loop);
	 
	*/
	
	public static int minSplit(int amount) {
		
		// შევქმენი მონეტების მასივი და დავალაგე კლებადობით.
	    int[] coins = {50, 20, 10, 5, 1}; 
	    
	    // შევქმენი ცვლადი, რომელიც დაითვლის while ციკლში გამოყენებული მონეტების რაოდენობას.
	    int count = 0; 
	    
	    // ვლუპავ coins მასივს მაქსიმალურიდან მინიმალურისკენ;
	    for (int coin : coins) {
	    	// while ლუპი კონკრეტულ მონეტას გამოიყენებს, იმდენჯერ, რამდენჯერაც შესაძლებელი იქნება(მაქსიმალურიდან მინიმალურისკენ);
	        while (amount >= coin) {
	        	// გამოყენებული მონეტის ღირებულებას ვაკლებ მთლიანი თანხის(თეთრებში) ღირებულებას, რაოდენობას კი ვზრდი;
	            amount -= coin;
	            count++;
	        }
	    }
	    
	    // ვაბრუნებ მნიშვნელობას, რომელიც აუცილებლად იქნება მინიმალური;
	    return count;
	}
	
	public static void main(String[] args) {
		
		System.out.println(minSplit(500));
		
	}

}
